<!DOCTYPE html>
<html>
<head>
<title>notes.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h2 id="notes-on-update">notes on update</h2>
<p>Поскольку для разработки и отладки интеллектуальной системы навигации требуется постоянная интеграция доработок алгоритмов на рабочем прототипе - разрабатывается минимальная работающая реализация платформы, реализующей интеллектуальную навигацию.</p>
<p>Первый этап разработки предусматривает создание мобильной платформы которая собирает весь спектр информации необходимый для построения разного типа карт. Далее на основе собранных данных производится отладка и доработка системы.</p>
<p>Для доработки системы до уровня стабильной высокопроизволительной системы навигации производится оценка требований и приводится стратегия по развитию каждого компонента системы до необходимого для дальнейшей интеграции уровня.</p>
<p>Для набора алгоритмов и аппаратной реализации производится оценка метрик и оценивается правильность выбора технологии.</p>
<h3 id="%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%B4%D0%B5%D0%BC%D0%BE%D0%BD%D1%81%D1%82%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B0-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B-%D0%BD%D0%B0%D0%B2%D0%B8%D0%B3%D0%B0%D1%86%D0%B8%D0%B8">Реализация демонстратора системы навигации:</h3>
<p>Порядок разработки системы предполагает предоставление демонстратора системы, далее доработку системы до готовой к интеграции инфраструктуры и набора алгоритмов.</p>
<p>Демонстратором является мобильная платформа, реализующая навигацию используя начальное GPS решение и далее только набор локальных датчиков для построения карты и локализации.</p>
<p>При низких общих требованиях к физической платформе, система должна демонстрировать весь основной функционал и базовые технологии работы интеллекутуальной системы навигации с инпользованием нейросетевых технологий.</p>
<p>Демонстрация должна показать работу следующих компонентов системы:</p>
<ul>
<li>Мобильная платформа (датчики, элементы управление и платформа) - рабочий прототип</li>
<li>Слияние датчиков и выбор конфигурации</li>
<li>Сбор картографических данных (LiDAR (LOAM) + воксельная карта)</li>
<li>Расчет карты (методы нейронной локализации + вспомогательные методы)</li>
<li>Автономная локализация (начальное GPS &gt;&gt; lidar + IMU + 1 Hz)</li>
<li>Оценка навигации + глобальная релокализация</li>
<li>Система для визуализация решения</li>
<li>Анализ передачи данных на сервер (передача потока изображений и облака точек)</li>
<li>Демонстрация + отчет по выполнению поставленных задач</li>
</ul>
<h2 id="%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%BF%D0%BB%D0%B0%D1%82%D1%84%D0%BE%D1%80%D0%BC%D1%8B-%D0%B8%D0%BD%D1%82%D0%B5%D0%BB%D0%BB%D0%B5%D0%BA%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9-%D0%BD%D0%B0%D0%B2%D0%B8%D0%B3%D0%B0%D1%86%D0%B8%D0%B8">Архитектура платформы интеллектуальной навигации</h2>
<p>Для понимания требований к аппаратной реализации системы, необходимо рассмотреть архитектуру интеллектуальной платформы навигации</p>
<p><img src="2022-09-04-18-28-34.png" alt=""></p>
<p>Система интеллектуальной навигации включает в себя несколько независимых модулей вычисления координаты пользователя.</p>
<p>Для работы системы в условиях недостаточной или шумной информации из определенных источников, интеллектуальная система навигации проектируется с возможностью максимального совместного исполльзования независимых источников информации.</p>
<p>Архитектура платформы интеллектуальной навигации определяется процедурой сбора и использования данных.</p>
<p>В зависимости от задачи и платформы варьируется набор доступных датчиков и производительность основного вычислительного модуля.</p>
<p>Исходим из принципа увеличения качества информации в системе.
Маскимальная точность алгоритма навигации будет при наличии всех возможных данных для каждой конкретной платформы в системе.
При этом реализация всегда ограничена конкретной платформой.</p>
<p>Например для смартфона невозможно использование специальных графических ускорителей, следовательно алгоритм должен выполняться на оригинальном процессоре.</p>
<p>Поскольку необходимо организовать выполнение задач по подготовке карты и передачи карты на клиентское устройство (смартфон) - рассмотрим клиент-серверную модель организации системы.</p>
<p>Необходимо определить какие процессы выполняются локально, какие на сервере. В случае разных конфигураций - мобильной платформы робота и телефона реализация будет частично различаться.</p>
<h3 id="%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F-%D1%81%D0%B1%D0%BE%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">технология сбора данных</h3>
<p>При сборе данных необходимо учитывать ограничения на сетевую пропускную способность системы.</p>
<p>Например</p>
<table>
<thead>
<tr>
<th style="text-align:center">Название стандарта видео</th>
<th style="text-align:center">Разрешение</th>
<th style="text-align:center">Размер часа видео</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">720p</td>
<td style="text-align:center">1280 x 720</td>
<td style="text-align:center">800 – 900MB</td>
</tr>
<tr>
<td style="text-align:center">1080p</td>
<td style="text-align:center">1920 x 1080</td>
<td style="text-align:center">1.2 – 1.4GB</td>
</tr>
<tr>
<td style="text-align:center">2K</td>
<td style="text-align:center">2048 x 1080</td>
<td style="text-align:center">2.8 – 3GB</td>
</tr>
<tr>
<td style="text-align:center">4K</td>
<td style="text-align:center">3840 x 2160</td>
<td style="text-align:center">20 – 22GB</td>
</tr>
</tbody>
</table>
<p>Рассчитаем размер карты для одной локации:</p>
<ul>
<li>Площадь 2000 м2</li>
</ul>
<p>Длина маршрута для покрытия площади:</p>
<p>$$
\begin{align}
l_{side} &amp;= \sqrt{s_{area}} \
n_{routes} &amp;= l_{side} / d_{discretisation} \
l_{cover} &amp;= l_{side} \cdot n_{routes} \cdot n_{repeates}  \
size_{all video} &amp;= l_{cover} / \frac{[v_{avg}]{m/s}}{60} \cdot [\rho] {Gb / min} \
&amp;= \frac{s_{area}[m^2] \cdot n_{repeates}[{\frac{1}{m}}]}{d_{discretisation}[{m}]} / \frac{v_{avg}[{m/s}]}{60} \cdot \rho [{Gb / min}]
\end{align}
$$</p>
<p>Для локации прямоугольной площади размером $s_{area} = 2000 m^2$ длиной стороны $\sqrt{s_{area}} = 45 m$,
если делать обходы локации вдоль линий каждые
${discretisation} = 10 m$ Получится определенная длина маршрута.</p>
<p>Поскольку съемка может вестись с разных стророн и для валидации решения необходимо оказаться в одной и той же локации несколько раз, записываем этот маршрут $n_{repeates} = 2.5$ раз.
Считаем среднюю скорость движения пешехода / записывающей платформы равной 3 м/с.</p>
<p>Если записывается только видео качества $freq = {1080p} / 30fps $, то итоговый размер файла ориентировочно равен:</p>
<p>$$
\begin{align}
l &amp;= \frac{2000 [m^2] \cdot 2.5[{\frac{1}{m}}]}{10 [{m}]} = 500[m] \
v &amp;= 3 \cdot 60 = 180[m/min] \
t &amp;=  500[m] / 180[m/min] = 2.8 [min] \
S &amp;= \cdot 1.4 [GB / min] \cdot 2.8 [min] = 3.92 GB
\end{align}
$$</p>
<p>Учитываем что битрейт может отличаться для различных камер и реализации алгоритма.</p>
<!-- 1080p/30fps at the bitrate of about 17Mbps -->
<p>Итоговый размер файла карты в 4 Гб - один запуск для одного пользователя.
Количество информации в минуту для одного пользователя равно соответственно битрейту (1 - 1.4 Gb/s). Поскольку при локализации не происходит обновления карты, можно не задумываться о потоковой передаче карты на сервер для случае обычного пользователя.</p>
<p>Если карту требуется создать и распространить, ее соответственно требуется передать на сервер и обработать. Конечный файл карты в идеале не должен занимать более 100 мб для пользователя смартфонов.</p>
<p>Если представить что набор изображений которые представляют карту сделаны с частотой 1 Hz, для 5 минут видео это примерно 300 изображений. Итоговая дискретизация пространства карты для скорости движения в 3 м/с составляет примерно одно изобрадение каждые 0.3 метра. Примерные значения поулчаются, поскольку маршрут пользователя не является прямой и изображения соответственно не распределены по пространству идеально равномерно.</p>
<p>С учетом коэффициента запаса (2.4) и широкоугольной линзы, считаем что в карте есть изображения в нескольких направлениях.
Для частоты выбор аключевых кадров в 1 Hz, итоговый вес файла будет равен отношению исходной частоты съемки к частоте сэмплирования (1/30) и итоговый файл карты будет 136 Мб в максимальном случае.</p>
<p>Представим, что карта может загружаться на пользовательское устройство постепенно - 50 Мб начальная карта на 1000 квадратных метров - окружность радиусом примерно в 16 м. Для скорости в 3 м/с, за 5 секунд пользователь должен скачать дополниительную часть карты в 50 Мб. Скорость мобильного интернета должна составлять 10 Мб/с - нереалистичный сценарий.</p>
<p>Следовательно, для худшего сценария сжатия карты и скорости выхода пользователя из текущей локации может существовать проблема размера карты.</p>
<p>Более реальный сценарий: карта с меньшей дискретизацией которая покрывает большую площадь - 50мб / 2000 м^2 - дискретизация меньше в два раза, но карта покрывает всю площадь локации. При нахождении пользователя в определенной точке локации - подгружаются ближайшие участки карты.</p>
<p>При использовании нейросетевых методов для кодирования карты - итоговый файл карты будет весить значительно меньше и позволит использование в ограниченных сетевых условиях как и однократную загрузку карты и дальнейшую работу в автономном режиме.</p>
<p>Конечное решение программной реализации на мобильном объекте навигации (смартфоне):
Нейронная локализация, сжатая, квантованная и компрессированная до возможностей смартфона.
Частота будет менее 1 Гц.</p>
<h2 id="%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B8%D0%BD%D1%82%D0%B5%D0%BB%D0%BB%D0%B5%D0%BA%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9-%D0%BD%D0%B0%D0%B2%D0%B8%D0%B3%D0%B0%D1%86%D0%B8%D0%B8">Решение интеллектуальной навигации</h2>
<!-- Target platform component solution: -->
<p>Cжатая, квантованная и компрессированная до возможностей смартфона система нейронной локализации обеспечивает стабильное решение навигации.</p>
<p>Программное обеспечение - это код на языке python со сжатой нейронной сетью.</p>
<!-- Odometry & asyncronous pose calculation: -->
<p>Получение высокочастотной координаты производится на основе интеграции IMU от последней рассчитанной локализации (3D-позиции).</p>
<p>Для точного решения с использованием IMU производится постоянная перекалибровка параметров интеграции измерений IMU.</p>
<p>Частота обновления системы может достигать до 100 Гц, задается требованиями приложения визуализации.
Поскольку для скорости движения пешехода порядка 3м/с - при размере экрана в 6см в ширину, если показывается площадь локации порядка 10 м. Смещение пользователя на 1 м составляет 0.6 см на экране. В случае применения адаптивного сглаживания траектории пользователя на экране, реально достаточно частоты 3 Hz для визуализации решения.
Для качественного обновления карты, сравнимо с максимально производительными системами навигации - достаточно частоты 25 Hz обновления решения системы + адаптивное сглаживание. Частота визуализации может составлять 25, 30, 50 и более кадров в секунду.</p>
<p>Большая частота обновления обозначает в первую очередь большую гладкость перемещения курсора на карте а не большую скорость перемещения.</p>
<p>Невозможно использовать реальную частоту обновления системы в интерфейсе пользователя - при шумном движении карты с частотой 25 кадров в секунду будет невозможно читать карту. Для большей отзывчивости системы настраиваются параметры сглаживания. Для разных реализаций существуют разные принципы параметров сглаживания: для системы помощи водителя - система должна работать максимально стабильно и не отвлекать водителя. Для реализации навигации со смартфоном актуальна высокая частота поворота - пользователь может определить свое направление на карте в реальном времени.</p>
<p>Возможны случаи движения пользователя с высокой скоростью: локальная система навигации установлена в автомобиле.</p>
<p>Для скорости движения в 100км/ч (27 м/с), частота решения в 100 Hz означает новое решение каждые 3.6 метра.
С условием размера экрана в 10 см в высоту и показывающего 150 метров карты (аналогично автомобильному навигатору для движения с аналогичной скоростью) получаем движение на 18% экрана в секунду. Новое решение на перемещение на каждые 2.4% экрана позволяет получить гладкое и стабильное решение.</p>
<p>В общем случае, для качественного решения навигации - существует запас по частоте вычисления.
В случае определения ситуации плохого решения навигации - возможно использовать адаптивное сглаживание для получения плавного решения.</p>
<!-- Navigine будет отвечать за визуализацию приложения и за то, как интегрировать его с обновлениями IMU -->
<p>Мера доверия к качеству локализации. Эта мера будет зависеть от результата выравнивания по отношению к карте. Мера используется на разных этапах использования итоговой координаты. В общем случае, нет необходимости вычисления этой меры в общем цикле вычислений.
Для такого рода сигналов можно задаться апертурой - когда невязка решения увеличивается более чем на определенную величину, производится перерасчет ошибки локализации.
В итоге расчет произволится только при определенных значениях невязки решения / каждый интервал времени.
При значительной ошибке решения можно попытаться осуществить глобальную релокализацию.</p>
<p>Например, мы вышли за границу скачанной карты - можно получить новое решение и новый участок карты с сервера.
В случае полного отсутсвия решения по причине отсутствия информации в карте, отсутствия информации с датчиков или другой причины - необходимо попытаться классифицировать ошибку, далее логировать ошибку и определенную причину ошибки.</p>
<p>В различных датасетах используемых для бенчмаркинга отмечаются простые и сложные последовательности для локализации. В дальнейшем можно использовать сохраненные последовательности записанные с клиентов для анализа и улучшения работы системы.</p>
<!-- 
Программное обеспечение: код на cpp, выполняющий интеграцию IMU. 
<!-- Позже это будет добавлено в Soft. 1.6. -->
<!-- Target end user interface: -->
<p>Конечная реализация интерфейса платформы локализации:</p>
<p>На основе опыта существующих решений пользовательской навигации, решением выбирается приложение для смартфона.</p>
<p>В такой реализации решение навигации начинается с получения данных от датчиков, затем запускается решение сжатого алгоритма для нейронной локализации.</p>
<!-- Concurrent robust computation: -->
<p>Для стабильной работы системы в максимально широком диапазоне локаций рассматриваем следующий дублирующий формат реализации  системы:
Быстрая локализация за счет интеграции IMU/одометрии и радиочастотного позиционирования. Такое относительное позиционирование обеспечит более высокую частоту, начиная с последней предоставленной достоверной локализации.</p>
<p>При отсутствии данных с камеры, возможно продолжать стабильную локализацию пользователя в высокой частотой.
Для реальных сценариев применения системы такое актуально для случаев когда человек входит в комнату - тереяется обзор камеры. Подобное поведение также характерно для высокодинамичесткого окружения - движение со смартфоном в толпе.</p>
<p>Программное обеспечение решения: код на для интеграции измерений IMU и перекалибровки датчиков.</p>
<!-- Robustness vs problem space exploration: -->
<p>Решение динамической системы - в общем случае это единственная координата или набор предполагаемых координат. В случае система не может сойтись к единственному решению или просто решение отсутсвует, существует модуль глобальной релокализации на случай сбоя системы.</p>
<p>Решением глобальной локализации может являться еще одна нейронная сеть, которая более равномерно покрывает все возможные локации пользователя.</p>
<!-- 
Мы предоставим сеть, осуществляющую более интенсивную локализацию, пытаясь преодолеть возможные потери системы локализации (2.4) -->
<p>Программное обеспечение модуля релокализации: код на cpp/python, на структуре, аналогичной системе локализации, но на большем пространстве состояний для проблемы глобальной локализации.</p>
<p>В общем случае решение может отсутвовать по причине отсутствия данных - в этом случае релокализация не поможет. Необходимо оценить работу системы сбор а и обработки данных, границы применимости каждой системы. Далее по результатам экспериментов производится подстройка системы и оптимизация гиперпараметров.
По итогам экспериментов определяется область применимости системы - возможные потенциальные применения, профиль использования.</p>
<h2 id="%D0%B0%D0%BF%D0%BF%D0%B0%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D0%BB%D0%B0%D1%82%D1%84%D0%BE%D1%80%D0%BC%D1%8B">Аппаратная реализация платформы</h2>
<!-- камеры, технология сбора данных, про сами карты, масштабирование системы -->
<!-- ### масштабирование системы -->
<p>Конечная аппаратная реализация включает ....</p>

</body>
</html>
